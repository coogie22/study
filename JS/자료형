```jsx
const name = "Mike";
const age = 30;

const name1 = "Mike"
const name2 = 'Mike'
const name3 = `Mike` (백틱 ``)

const message1 = "I'm a boy."
const message2 = `I\'m a boy'

const message3 = `My name is ${name}`
console.log(message3) = "My name is Mike"
```

const x = 1/0; 

이렇게 숫자를 0으로 나누면 infinity가 나옴 무한대

문자열을 숫자로 나누면 NaN값이 나옴 Not a Number

true = 참

false = 거짓

불리언 값에서 참은 숫자와 연관된 연산에서는 `1`로 취급됩니다. 예를 들어, `Number(true)`는 `1`을 반환하며, `true + 1`은 `2`가 됩니다. 마찬가지로, `false`는 숫자 `0`으로 취급됩니다.

null은 존재하지 않는 값

undefined 할당되지 않는 값

typeof 연산자는 변수의 자료형을 알아낼 수 있음

typeof null; = object(객체)

근데 null은 객체가 아님

`null`이 객체로 나오는 이유는 **JavaScript의 버그** 또는 **설계 상의 오류**로 인해 발생한 것입니다.

`null`은 실제로 "존재하지 않음" 또는 "값이 없음"을 나타내는 **원시 타입**(primitive type)입니다. 하지만 JavaScript의 초기 버전에서 `typeof null`이 "object"로 반환되도록 구현되어, 이 오류가 그대로 유지되었습니다. 기술적으로 `null`은 객체가 아니지만, 이 오래된 설계로 인해 `typeof null`이 "object"로 출력됩니다.

이 점은 JavaScript의 잘 알려진 특이점 중 하나입니다.

**객체**는 JavaScript를 포함한 많은 프로그래밍 언어에서 **데이터**와 그 데이터를 다루는 **메서드**(함수)를 함께 담고 있는 구조입니다. 객체는 **속성**(property)과 **메서드**로 구성되며, 속성은 객체가 가진 데이터를 나타내고, 메서드는 그 데이터를 처리하는 기능을 제공합니다.

예를 들어:

```jsx
const person = {
  name: "John",
  age: 30,
  greet: function() {
    console.log("Hello!");
  }
};

```

여기서 `person`은 객체이고, `name`과 `age`는 속성, `greet`는 메서드입니다.