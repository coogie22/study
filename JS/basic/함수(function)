```jsx
// 함수 작성

function showError(){
    alert("에러");
}

showError();
```

```jsx
// 매개변수가 있는 함수

function sayHello(name1){
    const msg = `Hello ,,,,,,,,,,,,,,,,,,,,,,,, ${name1}`;
    console.log(msg);
}

sayHello("mmmm")
```

이 코드는 **매개변수가 있는 함수**를 정의하고, 그 함수를 호출하여 **콘솔에 메시지를 출력**하는 코드입니다. 각 부분을 설명하면 다음과 같습니다:

### 코드 설명:

```jsx
// 매개변수가 있는 함수
function sayHello(name1) {
    // 템플릿 리터럴을 사용하여 메시지를 정의하고 name1 매개변수 값을 포함
    const msg = `Hello ,,,,,,,,,,,,,,,,,,,,,,,, ${name1}`;

    // 메시지를 콘솔에 출력
    console.log(msg);
}

// 함수 호출, "mmmm"이 매개변수로 전달됨
sayHello("mmmm");

```

### 1. **함수 정의 (Function Definition)**:

```jsx
function sayHello(name1) {
    // ...
}

```

- `sayHello`라는 이름의 함수를 정의합니다.
- 이 함수는 **`name1`*이라는 **매개변수(parameter)**를 받습니다. 이 매개변수는 함수가 호출될 때 전달되는 값을 담습니다.

### 2. **템플릿 리터럴 사용 (Template Literal)**:

```jsx
const msg = `Hello ,,,,,,,,,,,,,,,,,,,,,,,, ${name1}`;

```

- **템플릿 리터럴**(```)을 사용하여 문자열을 생성하고, **`${name1}`** 부분에 **`name1` 변수의 값**이 삽입됩니다.
- 이 경우 `"Hello ,,,,,,,,,,,,,,,,,,,,,,,, mmmm"`이라는 메시지가 만들어집니다.
- `name1`으로 전달된 값은 함수 호출 시 입력한 `"mmmm"`입니다.

### 3. **콘솔에 메시지 출력 (Logging Output)**:

```jsx
console.log(msg);

```

- 생성된 메시지를 **콘솔에 출력**합니다. 출력된 결과는 다음과 같습니다:
    
    ```
    Hello ,,,,,,,,,,,,,,,,,,,,,,,, mmmm
    
    ```
    

### 4. **함수 호출 (Function Call)**:

```jsx
sayHello("mmmm");

```

- **`sayHello` 함수**를 호출할 때, **`"mmmm"`*을 인수(argument)로 전달합니다.
- 이때 **`name1`** 매개변수에 `"mmmm"`이 할당됩니다.
- 함수가 실행되면서 콘솔에 `"Hello ,,,,,,,,,,,,,,,,,,,,,,,, mmmm"`이 출력됩니다.

### 요약:

- 이 코드는 **매개변수**를 받아서 `"Hello ,,,,,,,,,,,,,,,,,,,,,,,, [이름]"`이라는 메시지를 생성하고 콘솔에 출력하는 함수입니다.
- `sayHello("mmmm")`라고 호출하면, `name1`에 `"mmmm"`이 전달되어, 최종적으로 **콘솔에 메시지**가 출력됩니다.

```jsx
// 매개변수가 있는 함수

function sayHello(name1){
    let msg = 'hello';
    if(name1){
        msg += ' '   + (name1);
    }
    console.log(msg);
}

sayHello();
sayHello(32423);

```

이 코드는 **매개변수가 있는 함수**를 정의하고, 다양한 인수로 **함수를 호출**하여 **콘솔에 메시지를 출력**하는 예시입니다. 각 부분을 상세히 설명하겠습니다:

### 코드 설명:

```jsx
// 매개변수가 있는 함수
function sayHello(name1) {
    // 기본 메시지 설정
    let msg = 'hello';

    // name1이 존재할 경우, 메시지에 name1을 추가
    if (name1) {
        msg += ' ' + name1;
    }

    // 메시지를 콘솔에 출력
    console.log(msg);
}

// 함수 호출: 매개변수 없이 호출
sayHello();  // 출력: "hello"

// 함수 호출: 매개변수로 32423을 전달
sayHello(32423);  // 출력: "hello 32423"

```

### 1. **함수 정의 (Function Definition)**:

```jsx
function sayHello(name1) {
    // ...
}

```

- `sayHello`라는 이름의 함수를 정의합니다.
- 이 함수는 **`name1`*이라는 매개변수를 받아서 처리합니다.

### 2. **기본 메시지 설정 (Initial Message Setup)**:

```jsx
let msg = 'hello';

```

- **`msg`** 변수를 `'hello'`로 초기화합니다.
- 이 기본 메시지가 후에 수정될 수 있습니다.

### 3. **조건문을 통한 메시지 수정 (Conditional Message Modification)**:

```jsx
if (name1) {
    msg += ' ' + name1;
}

```

- *`name1`*이 존재하거나 `null`이 아닌 값을 가질 때 (`name1`이 **truthy**일 때) 이 조건문이 실행됩니다.
- `msg`에 공백(`' '`)과 `name1` 값을 추가합니다.
- `name1`이 **정수**일 경우도 문제없이 문자열로 처리되어 메시지에 추가됩니다.

### 4. **메시지 출력 (Logging Output)**:

```jsx
console.log(msg);

```

- `msg` 변수에 저장된 메시지를 **콘솔에 출력**합니다.

### 5. **함수 호출 (Function Calls)**:

- **매개변수 없이 호출**:
    
    ```jsx
    sayHello();  // 출력: "hello"
    
    ```
    
    - `name1`이 전달되지 않으므로 `if (name1)` 조건문이 **false**가 되어 `msg`는 `'hello'` 그대로 출력됩니다.
- **매개변수로 `32423`을 전달**:
    
    ```jsx
    sayHello(32423);  // 출력: "hello 32423"
    
    ```
    
    - `name1`에 `32423`이 전달되므로 `if (name1)` 조건문이 **true**가 되어 `msg`는 `'hello 32423'`로 수정됩니다.
    - 결과적으로 `"hello 32423"`이 콘솔에 출력됩니다.

### 요약:

- `sayHello` 함수는 **매개변수**로 받은 값을 기반으로 메시지를 생성하고, **콘솔에 출력**합니다.
- **매개변수가 없을 때**는 기본 메시지 `'hello'`만 출력되고, **매개변수가 있을 때**는 `'hello'`와 함께 매개변수 값이 추가된 메시지가 출력됩니다.

네, 맞습니다. 코드에서 `msg`는 **지역 변수**입니다. 이를 좀 더 자세히 설명하겠습니다.

### 지역 변수와 전역 변수

- **지역 변수 (Local Variable)**:
    - **지역 변수**는 특정 함수의 **스코프** 안에서만 유효합니다.
    - 함수 내부에서 선언된 변수는 그 함수 블록 내에서만 접근 가능하며, 함수 외부에서는 접근할 수 없습니다.
- **전역 변수 (Global Variable)**:
    - **전역 변수**는 스크립트 전체에서 유효하며, 함수 외부에서 선언됩니다.
    - 함수 내부와 외부 모두에서 접근할 수 있습니다.

### 코드에서의 `msg` 변수

```jsx
function sayHello(name1) {
    let msg = 'hello';  // 'msg'는 이 함수 내에서만 유효한 지역 변수입니다.

    if (name1) {
        msg += ' ' + name1;  // 'msg'는 여전히 이 함수 내에서만 유효합니다.
    }

    console.log(msg);  // 'msg'는 이 함수 내에서만 유효하여 콘솔에 출력됩니다.
}

```

- `msg` 변수는 **`sayHello`** 함수 내에서 선언되었기 때문에 **지역 변수**입니다.
- 이 함수가 호출될 때마다 `msg` 변수는 새로운 값을 가지며, 함수 호출이 끝나면 `msg` 변수는 **메모리에서 사라집니다**.
- 다른 함수나 코드 블록에서는 이 `msg` 변수에 접근할 수 없습니다.

### 예제

다음과 같은 코드에서 `msg`는 지역 변수로 작동합니다:

```jsx
function exampleFunction() {
    let msg = 'hello';
    console.log(msg);  // 'hello'
}

exampleFunction();
console.log(msg);  // 오류: 'msg'는 exampleFunction 함수 내에서만 유효한 지역 변수입니다.

```

이 코드에서 `console.log(msg)`가 함수 외부에서 호출되면 오류가 발생합니다. 이는 `msg`가 `exampleFunction` 함수의 **지역 변수**이기 때문입니다.

따라서, **`msg`**는 **`sayHello`** 함수 내부에서만 유효하며, **지역 변수**로 취급됩니다.

함수를 사용할 때 **지역 변수**를 사용하는 것이 일반적으로 더 바람직한 이유를 설명하겠습니다.

### 지역 변수를 사용하는 이유

1. **스코프의 제한**:
    - **지역 변수**는 함수 내부에서만 유효하므로, 함수 외부의 코드와 **충돌할 가능성이 적습니다**. 이는 코드의 예측 가능성과 안정성을 높여줍니다.
2. **캡슐화**:
    - 함수 내에서 사용하는 데이터나 상태는 함수의 **내부**에서만 관리되므로, 외부 코드에서 **변경**할 수 없게 됩니다. 이는 함수의 **무결성**을 유지하는 데 도움이 됩니다.
3. **메모리 관리**:
    - **지역 변수**는 함수 호출 시 생성되고 함수 호출이 끝나면 메모리에서 사라집니다. 따라서, 불필요한 메모리 사용을 줄일 수 있습니다.
4. **코드 가독성**:
    - **지역 변수**는 함수 내부에서만 사용되므로, **함수의 동작**과 **변수의 역할**이 명확해집니다. 이는 코드의 **가독성**을 높이는 데 도움이 됩니다.
5. **예상치 못한 사이드 이펙트 방지**:
    - **전역 변수**를 사용하면 다른 코드에서 전역 변수를 **변경**할 수 있어 예기치 않은 **사이드 이펙트**를 일으킬 수 있습니다. 반면, **지역 변수**는 함수의 **범위** 내에서만 변경되므로 이런 문제가 줄어듭니다.

### 예제

다음은 지역 변수를 사용하는 함수의 예입니다:

```jsx
function calculateTotal(price, taxRate) {
    let tax = price * taxRate;  // 'tax'는 지역 변수입니다.
    let total = price + tax;    // 'total'도 지역 변수입니다.
    return total;
}

console.log(calculateTotal(100, 0.1));  // 출력: 110

```

- `tax`와 `total`은 **지역 변수**로, **`calculateTotal`** 함수 내에서만 사용됩니다.
- 함수 호출이 끝나면 이 변수들은 메모리에서 사라집니다.
- **전역 변수**가 아닌 **지역 변수**를 사용하여 **변수 충돌**을 방지합니다.

### 전역 변수를 사용할 경우

전역 변수는 **전체 스크립트에서 유효**하므로 다음과 같은 상황에서 문제가 발생할 수 있습니다:

1. **변수 충돌**:
    - 여러 함수가 같은 이름의 전역 변수를 사용할 경우, 서로 영향을 미칠 수 있습니다.
2. **디버깅 어려움**:
    - 전역 변수를 수정하는 코드가 많으면 **디버깅**이 어려워질 수 있습니다.
3. **상태 관리 어려움**:
    - 전역 상태를 관리하는 것이 **복잡**해질 수 있습니다, 특히 대규모 애플리케이션에서는 더욱 그렇습니다.

결론적으로, **지역 변수**를 사용하면 코드의 **안정성**과 **가독성**을 높일 수 있습니다. **전역 변수**는 필요할 때 신중하게 사용해야 하며, 가능한 한 지역 변수로 문제를 해결하는 것이 좋습니다.

반환 return

```jsx
function add(num1 , num2){
    return num1 + num2;
}

const result = add(2 , 3);
console.log(result);
```

함수(function)