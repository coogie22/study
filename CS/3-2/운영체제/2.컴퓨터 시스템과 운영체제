// 20241015 운영체제

컨텍스트(문맥) - 프로그램이 실해 중인 일체의 상황

프로그램 카운터(PC) - 명령어가 담겨져 있는 메모리의 주소를 PC에 담겨져 있음

### **PC (Program Counter) - 프로그램 카운터**

프로그램 카운터는 현재 실행 중인 프로세스의 다음 명령어 주소를 저장하는 레지스터입니다. CPU는 프로그램 카운터에 저장된 주소를 읽어 해당 명령어를 가져와 실행하며, 프로그램 카운터는 실행될 다음 명령어의 주소로 자동으로 증가합니다.

**역할**: CPU가 프로그램 실행 흐름을 제어할 수 있도록 명령어의 순서를 추적합니다.

### **SP (Stack Pointer) - 스택 포인터**

스택 포인터는 스택이라는 메모리 구조의 최상위 요소를 가리키는 레지스터입니다. 스택은 후입선출(LIFO, Last In First Out) 구조를 따르며, 주로 함수 호출 시 반환 주소, 지역 변수, 함수 인자 등을 저장하는 데 사용됩니다.

**역할**: 스택에 데이터를 push(저장)하거나 pop(추출)할 때, 스택 포인터는 항상 스택의 최상단을 가리킵니다.

요약

- **운영체제(OS)**: 하드웨어와 소프트웨어 사이에서 시스템 자원을 관리하고 사용자가 프로그램을 실행할 수 있게 해주는 소프트웨어.
- **프로그램 카운터(PC)**: 다음에 실행될 명령어의 메모리 주소를 저장하는 레지스터.
- **스택 포인터(SP)**: 함수 호출과 반환 시 스택의 최상단 위치를 추적하는 레지스터.

컨텍스트 스위칭

발생

CPU가 현재 프로그램의 실행을 중지하고 다른 프로그램을 실행할 때

과정
현재 실행중인 프로그램의 컨텍스트(CPU레지스터들의 값)를 메모리에 저장
새로 실행시킬 프로그램의 저장된 컨텍스트(CPU레지스터들의 값)를 CPU에 복귀

멀티 코어

1개의 cpu안의 여러 개의 코어

### 3.1 **병렬 처리로 인한 성능 향상**

멀티코어 프로세서는 여러 코어가 동시에 여러 작업을 병렬로 처리할 수 있기 때문에, 처리 속도가 크게 향상됩니다. 특히, 멀티스레드 프로그램의 경우 각 스레드가 각기 다른 코어에서 병렬로 실행되므로 성능이 매우 향상됩니다.

이를 통해 성능 향상, 멀티태스킹의 효율성, 전력 효율성, 확장성 등의 이점을 누릴 수 있습니다.

컴퓨터 시스템 계층 구조

""

계층 구조로 설계된 이유

계층간 독립성 확보를 위해 

사용자 - 운영체제나 하드웨어에 몰라도 응용프로그램 활용 가능

응용프로그램 - 하드웨어 타입이나 구조 , 제어 방법을 몰라도 개발 가능 , 하드웨어가 바뀌어도 다시 작성할 필요 없음

운영체제 - 장치 관련된 모든 작업을 디바이스 드라이버에게 요청

왜 운영체제가 필요한가?

운영체제가 없다면 사용자가 직접 하드웨어를 제어해야 함 , 하드웨어에 대한 지식이 필요하며 충돌 , 관리 , 보안 문제 발생

프로세스 , 메모리 , 장치 , 파일 시스템 , 입출력 관리 필요

운영체제와 응용프로그램 사이의 관계

응용프로그램에 대한 운영체제의 역할

응용프로그램이 직접 하드웨어를 다루지 못하도록 차단 

이유 : 응용프로그램들 사이의 하드웨어 사용 충돌을 막기 위함

응용프로그램이 하드웨어를 사용하고자 할 때
반드시 운영체제에게 요청 -> 운영체제가 대신하여 하드웨어 조작
유일한 요청 방법 – 시스템 호출(system call)

운영체제와 사용자의 관계
사용자는 응용프로그램을 통해 컴퓨터 활용

사용자가 하드웨어에 관한 지식이 없어도 컴퓨터 다루기 용이
사용자가 하드웨어를 설치하거나 변경하는 것에 도움

운영체제와 하드웨어의 관계
하드웨어를 제어하는 것은 전적으로 운영체제의 몫

하드웨어 제어는 전적으로 운영체제의 기능

운영체제의 전체 기능

프로세스와 스레드 관리 - 프로세스/스레드의 실행, 일시 중단, 종료, 스케줄링, 컨텍스트 스위칭, 동기화

메모리 관리 - 프로세스나 스레드에게 메모리 할당, 메모리 반환, 다른 프로세스/스레드로부터의 메모리 보호 , 메모리를 하드 디스크의 영역까지 확장하는 가상 메모리 기술

파일 관리 혹은 파일 시스템 관리 - 파일 생성, 저장, 읽기, 복사, 삭제, 이동, 파일 보호

장치 관리 - 키보드, 마우스, 프린터 등 입출력 장치, 하드 디스크 등 저장 장치 제어 , 입출력

사용자 인터페이스 - 라인 기반 명령 입출력 창, 마우스와 그래픽 사용 GUI 인터페이스 제공

네트워킹 - 네트워크 인지, 연결, 닫기, 데이터 송수신

보호 및 보안
바이러스나 웜, 멀웨어(malware), 해킹 등의 외부 공격이나 무단 침입으로부터 보호

운영체제의 구성 요소와 커널

시스템 콜 - 소프트웨어 인터럽트를 유도하게 됨

디바이스 드라이버가 하드웨어를 제어하게 됨 하드웨어가 보고하게 됨

보라색은 인터럽트라는 뜻 

인터럽트는 하드웨어 제어기가 cpu에게 보내는 전기적 신호

하드웨어 안에서 나오는 신호 - 인터럽트

입출력 장치 제어기가 cpu에게 신호를 보내서 cpu에게 동작을 멈추게하는 매커니즘을 인터럽트라고 함

결과적으로 운영체제가 인터럽트를 해결하기 위해 디바이스가 동작하는 것

운영체제 구성
운영체제 = 커널 + 툴 + 디바이스 드라이버

커널 - 시스템 자원을 제어하고 , 관리하는 코드와 자료구조들

특징 - 커널 코드는 함수들의 집합 , 커널 기능을 이용하려면 응용프로그램은  반드시 시스템 호출 사용 , 운영체제의 핵싱 기능 모두 구현

도구 소프트웨어와 gui

사용자가 컴퓨터를 편리하게 사용할 수 있도록 제공하는 툴 , 응용프로그램

윈도우는 바탕화면 gui , 탐색기 , 명령창 , 작업 관리자

디바이스 드라이버

◼ 장치를 직접 제어하고 입출력하는 소프트웨어
◼ 장치마다 전담 디바이스 드라이버 있음
◼ 일반적으로 장치 제작자에 의해 작성되어 배포됨
◼ 사례
◼ 키보드 드라이버, 디스크 드라이버, SCSI 드라이버, 마우스 드라이버, 그래픽 드라이버, 네트워크 드라이버, usb 드라이버 등

운영체제 커널 인터페이스 : 시스템 호출과 인터럽트

커널이 제공하는 2개 인터페이스 : 시스템 호출과 인터럽트
◼ 응용프로그램과 하드웨어 사이의 중계 역할

시스템 호출(system call)
 커널과 응용프로그램 사이의 인터페이스
 응용프로그램에서 커널 기능을 사용할 수 있는 유일한 방법
 시스템 호출 라이브러리를 통해 다양한 시스템 호출 함수 제공
◼ 시스템 호출 라이브러리는 운영체제 패키지에 포함됨
◼ 예) 파일 읽기, 메모리 할당, 프로세스 정보 보기, 프로세스 생성 등

표준 라이브러리(standard library)란?
• 응용프로그램을 쉽게 작성할 수 있도록 복잡한 기능이 미리 작성된 코드

운영체제 커널 인터페이스 - 인터럽트

인터럽트(interrupt)
 커널과 하드웨어 장치 사이의 인터페이스

장치들이 입출력 완료나 타이머 완료등 cpu에게 전송

인터럽트가 발생하면
◼ CPU는 하는 일을 중단하고 인터럽트 서비스 루틴 실행

인터럽트 서비스 루틴은 대부분 디바이스 드라이버 내에 있음
◼ 예) 키를 입력하면 커널의 키보드 인터럽트 서비스 루틴 실행, 키를 읽어 커널 버퍼에 저장
◼ 인터럽트 서비스 루틴은 커널 영역에 적재
◼ 인터럽트 서비스 루틴의 실행을 마치면 하던 작업 계속
 인터럽트 활용
◼ 운영체제가 장치에게 지시한 입출력 작업의 완료, 예고 없는 네트워
크 데이터의 도착, 키보드나 마우스의 입력, 부족한 배터리 경고 등
장치와 관련된 모든 이벤트 처리

*** 다음주 목요일까지 배운 범위가 시험 범위


// 20241022 



사용자 공간 크기
 한 응용프로그램의 최대 크기 결정
◼ 프로그램 코드 + 데이터(전역변수) + 힙(동적할당) + 스택 합친 크기
◼ 예) 32비트 Windows 운영체제에서 사용자 공간 2GB란 ->
응용프로그램을 2GB 크기 이상 개발할 수 없음
 사용자 공간의 주소 범위
 응용프로그램은 운영체제가 설정한 사용자 공간의 주소 범위를
넘어설 수 없음
◼ 예) 32비트 Windows 운영체제에서,
응용프로그램은 0~7FFFFFFF 범위의 주소를 넘어 액세스하면,
바로 종료(심각한 오류)

2가지 의문 

- 실제 물리 메모리가 4GB보다 작은 경우는 ?
- 응용프로그램들의 사용자 공간 충돌 ?

사용자 공간의 충돌 해결

- 물리 메모리를 여러 응용프로그램의 사용자 공간을 나누어 사용

(실제 각 응용프로그램은 사용자 공간의 일부만 사용)

- 커널 공간 역시 물리 메모리에 매핑

(각 응용프로그램의 매핑 테이블에 기록)

물리 메모리가 작은 경우에 대한 해결

- 물리 메모리가 부족하면 운영체제는 물리 메모리를 하드 디스크에 저장하여 물리 메모리의 빈 영역 확보(가상 메모리 기법)

사용자 모드와 커널 모드

cpu는 사용자 모드와 커널 모드 중 한 모드로 실행

cpu 내부에 모드 상태를 나타내는 “모드 레지스터”있음

- 사용자 모드(user mode)

cpu의 모드 비트 = 1

cpu는 사용자 공간에 있는 코드나 데이터를 액세스 하는 중

cpu의 커널 공간 접근 불허 - > 응용프로그램으로부터 커널 영역 보호

특권 명령 실행 불허 

특권 명령 - 입출력 장치 등 하드웨어나 시스템 중단 등 시스템 관련 처리를 위해 설계된 특별한 명령

- 커널 모드(kernel mode)

cpu의 모드 비트 = 0

cpu가 커널 공간에서 실행하는 중 

특권 명령 사용 가능

- 사용자 모드에서 커널 모드로 전환

오직 2가지 경우 - 시스템 호출과 인터럽트 발생

시스템 호출

시스템 호출을 실행하는 특별한 기계 명령에 의해 진행

기계 명령이 cpu의 모드 비트를 커널 모드로 전환

인터럽트

cpu가 인터럽트를 수신하면 커널 모드로 자동 전환(인터럽트 루틴이 커널 공간에 있기 때문)

cpu는 인터럽트 서비스 루틴 실행

인터럽트 서비스 루틴이 끝나면 cpu는 사용자 모드로 자동 전환 

- *사용자 모드(User Mode)**와 **커널 모드(Kernel Mode)**는 운영체제의 두 가지 주요 실행 모드로, 시스템 자원의 접근 권한 및 처리 권한을 다르게 적용합니다. 이를 통해 시스템의 안정성, 보안성을 강화하고, 오류나 악성 코드로부터 시스템을 보호할 수 있습니다.

### 1. **사용자 모드 (User Mode)**

- **정의**: 사용자 모드는 응용 프로그램(사용자 프로그램)이 실행되는 모드입니다. 이 모드에서는 하드웨어나 운영체제의 핵심 자원에 직접 접근할 수 없습니다.
- **권한**: 제한된 권한을 가집니다. 프로그램이 운영체제의 중요한 자원이나 메모리 영역에 직접 접근할 수 없도록 제한됩니다.
- **안전성**: 응용 프로그램이 버그나 악성 코드로 인해 문제를 일으키더라도, 다른 프로그램이나 운영체제에 직접적인 영향을 미치지 않도록 설계되었습니다. 오류가 발생하면 해당 응용 프로그램만 종료되거나 에러 메시지를 반환합니다.
- **실행 가능한 작업**:
    - 기본적인 연산 및 데이터 처리
    - 제한된 메모리 접근 (자신에게 할당된 메모리 공간만 접근 가능)
    - 운영체제에 요청을 통해서만 하드웨어 자원 접근 가능 (예: 시스템 호출을 통해 파일을 열거나 네트워크 사용)
- **대표적인 작업**: 응용 프로그램(웹 브라우저, 게임, 워드 프로세서 등)의 실행

### 2. **커널 모드 (Kernel Mode)**

- **정의**: 커널 모드는 운영체제의 핵심 부분이 동작하는 모드로, 하드웨어 자원에 직접 접근하고 시스템 전반을 관리하는 역할을 수행합니다.
- **권한**: 최상위 권한을 가지며, 모든 시스템 자원에 자유롭게 접근할 수 있습니다. 메모리, CPU, 디스크, 네트워크 등의 하드웨어 자원에 직접 접근하거나 제어할 수 있습니다.
- **안전성**: 커널 모드에서 실행되는 코드가 오류를 일으키면 시스템 전체에 심각한 영향을 미칠 수 있습니다. 커널 모드는 보호되지 않기 때문에, 버그나 악성 코드로 인한 시스템 장애(블루스크린 등)가 발생할 가능성이 높습니다.
- **실행 가능한 작업**:
    - 모든 메모리 공간에 접근 가능
    - 모든 하드웨어 자원 제어 (디스크, 네트워크, 메모리, I/O 장치)
    - 스케줄링 및 자원 할당
    - 파일 시스템 및 네트워크 관리
- **대표적인 작업**: 운영체제의 핵심 기능(파일 시스템, 메모리 관리, 프로세스 관리, 장치 드라이버 등)

### 3. **비교**

| **항목** | **사용자 모드 (User Mode)** | **커널 모드 (Kernel Mode)** |
| --- | --- | --- |
| **권한** | 제한된 권한 | 최고 권한 |
| **자원 접근** | 시스템 자원에 직접 접근 불가 | 시스템 자원에 직접 접근 가능 |
| **메모리 접근** | 자기 메모리 공간만 접근 가능 | 모든 메모리 공간 접근 가능 |
| **보안 및 안정성** | 응용 프로그램 오류가 시스템에 영향을 미치지 않음 | 커널 모드 오류 시 시스템 전체에 영향을 미칠 수 있음 |
| **실행 속도** | 커널 모드에 비해 느림 | 사용자 모드보다 빠름 |
| **주요 용도** | 응용 프로그램 실행 | 운영체제 기능 구현, 장치 드라이버 실행 |
| **예시** | 웹 브라우저, 게임, 오피스 프로그램 등 | 운영체제 커널, 장치 드라이버, 메모리 관리 시스템 등 |

### 4. **모드 전환**

사용자 모드에서 실행되는 응용 프로그램이 시스템 자원(파일 시스템, 네트워크 등)을 사용하고자 할 때는 직접 접근할 수 없으므로, **시스템 호출(System Call)**을 통해 커널 모드에서 처리하도록 요청합니다. 이때 사용자 모드에서 커널 모드로 전환이 일어나며, 커널이 해당 요청을 처리한 후 다시 사용자 모드로 전환됩니다.

이 모드 전환 과정은 안전을 보장하지만, 성능 측면에서는 오버헤드가 발생할 수 있습니다.

Q. 다음 보기 중 어떤 명령이 특권 명령일까? 이유도 설명하라.
 1) 사용자 모드에서 커널 모드로 전환시키는 명령
◼ 특권 명령이 아니다.
◼ 왜냐하면 시스템 호출을 위해 모든 응용 프로그램에게 허용되어야 하는 명령이기 때문이
다.
 2) 시계 읽기
◼ 특권 명령이 아니다.
◼ 모든 응용프로그램에서 시계를 읽을 수 있어야 하기 때문이다.
 3) 가상 메모리에서 메모리 지우기
◼ 특권 명령이 아니다.
◼ 프로그램이 자신의 메모리 부분을 지우는 것은 다른 프로세스의 영역을 침범하지 않기
때문이다.
 4) 인터럽트 끄기
◼ 특권 명령이다.
◼ 인터럽트를 끄는 행위는 CPU 내부의 인터럽트 플래그(IF)를 끄는 행동으로, 인터럽트가
꺼지면 외부에서 인터럽트가 발생해도 CPU는 인터럽트의 발생을 체크하지 않는다. 한 프
로그램이 인터럽트를 끄면 CPU는 인터럽트가 꺼진 상태로 계속 있게 되어, CPU가 다른
프로그램을 실행하더라도 인터럽트를 받을 수 없게 된다. CPU는 한 프로그램에게 독점될
수 없기 때문에 이 명령은 특권 명령으로 응용프로그램이 실행할 수 없다.

실행 모드와 관련된 다양한 이슈

사용자 모드와 커널 모드는 CPU에 의해 구현되는가, 운영체제에 의
해 구현되는가?

모드는 cpu에 의해 구현되고 운영체제가 활용하는 기능

cpu 내부에 모드를 나타내는 레지스터 존재

운영체제가 사용자 모드와 커널 모드로 나누어 작동시키는 이유는?

커널 공간에 대한 보안과 보호

사용자 응용프로그램은 사용자 모드에서 아무리 심각한 오류가 발생해도 사용자 프로그램만 종료시킬 수 있고 시스템을 중단시키지는 못함

사용자 프로그램이 커널 코드를 호출하는 일은?

사용자 응용프로그램을 직접 커널 코드 호출 불가

cpu가 커널 모드와 사용자 모드 중 어떤 모드로 많이 실행?

시스템 전체 통계를 보면 커널 모드에서 많이 실행

- 커널의 실체

커널은 부팅 시에 커널 공간에 적재된 함수들과 데이터 집합

커널은 컴파일된 바이너리 형태, 하드디스크 특정 영역에 저장, 부팅 시에 커널 공간의 메모리에 적재

커널 코드는 함수들의 집합

커널의 존재 - 커널 모드에서 실행되는 함수들과 데이터들의 집합

* 현재 커널 코드를 실행하고 있는 것은 누구인가? app2 프로세스이다. 커널 프로세스란 말은 없다. 커널은 프로세스가 아니다.

커널이 **프로세스**가 아닌 이유는, 커널의 역할과 프로세스의 역할이 서로 근본적으로 다르기 때문입니다. 이를 설명하기 위해서는 **커널과 프로세스의 차이점**과 커널이 운영체제 내에서 어떤 역할을 수행하는지 이해하는 것이 중요합니다.

### 1. **프로세스란 무엇인가?**

- **프로세스**는 **실행 중인 프로그램**을 의미합니다. 프로그램이 메모리 상에서 실행될 때, 운영체제는 프로그램에 할당된 자원(CPU 시간, 메모리 공간 등)을 관리하고 보호합니다.
- 프로세스는 **독립적인 실행 단위**로, 각 프로세스는 운영체제로부터 고유한 주소 공간을 할당받고 다른 프로세스와 독립적으로 실행됩니다.
- 프로세스는 사용자 모드에서 실행되며, 자원에 접근하기 위해서는 커널에 요청해야 합니다.

### 2. **커널이란 무엇인가?**

- **커널**은 운영체제의 **핵심**으로, 시스템 전체를 관리하고, 하드웨어와 소프트웨어 간의 인터페이스를 제공하는 역할을 합니다. 커널은 시스템 자원(메모리, CPU, 디스크 등)을 관리하고, 프로세스 간의 통신, 파일 시스템 관리, 장치 제어 등을 담당합니다.
- 커널은 **커널 모드**에서 실행되며, 시스템 전체의 자원에 대한 **최고 권한**을 가지고 있습니다.
- 커널은 모든 프로세스의 실행을 제어하고, 시스템 자원을 효율적으로 할당하는 역할을 합니다. 따라서 커널은 프로세스들의 작업을 관리하고 조정하는 상위 개념입니다.

### 3. **커널이 프로세스가 아닌 이유**

- **독립적인 실행 단위가 아님**: 커널은 프로세스처럼 독립적인 실행 단위가 아닙니다. 프로세스는 운영체제에 의해 할당된 자원을 사용하면서 동작하지만, 커널은 시스템 전체를 제어하고 관리하는 역할을 수행합니다. 커널 자체가 독립적인 실행 단위로 동작하는 것이 아니라, **프로세스의 동작을 관리하고 중재하는 존재**입니다.
- **주소 공간 차이**: 프로세스는 사용자 모드에서 **독립적인 가상 주소 공간**을 가집니다. 각 프로세스는 다른 프로세스와 메모리 공간을 공유하지 않으며, 메모리 충돌을 방지하기 위해 운영체제가 메모리를 보호합니다. 그러나 커널은 모든 메모리 영역을 직접적으로 접근할 수 있으며, 이를 통해 여러 프로세스의 자원을 관리합니다. 커널은 **독립적인 주소 공간을 가지지 않고** 모든 프로세스의 자원을 관리할 수 있는 최고 권한을 가집니다.
- **운영체제의 핵심**: 커널은 단순히 하나의 실행 중인 프로그램(프로세스)이 아니라, 운영체제의 가장 핵심적인 부분입니다. 프로세스는 커널에 의해 관리되고 제어되지만, 커널은 그런 관리의 대상이 아닙니다. **프로세스는 커널의 제어하에 있고**, 커널은 운영체제 전반을 통제하며 시스템 자원을 효율적으로 배분하는 관리자 역할을 합니다.
- **커널 모드 vs 사용자 모드**: 프로세스는 주로 **사용자 모드**에서 실행됩니다. 사용자 모드에서는 제한된 자원에만 접근할 수 있고, 운영체제의 중요한 자원은 커널을 통해서만 접근할 수 있습니다. 커널은 **커널 모드**에서 실행되며, 시스템의 모든 자원에 접근하고 제어할 수 있습니다. 따라서 커널은 사용자가 실행하는 일반적인 프로그램(프로세스)과는 다른 특수한 실행 환경을 가지고 있습니다.

### 4. **프로세스와 커널 간의 관계**

- 프로세스는 자원을 요청할 때마다 커널에게 **시스템 호출(System Call)**을 합니다. 이때 커널이 해당 요청을 처리하고, 필요한 자원을 할당하거나 관리합니다.
- 커널은 시스템의 모든 프로세스를 관리하는 관리자 역할을 수행하며, **프로세스 간의 자원 경쟁을 중재**하고, **CPU 스케줄링**을 통해 각 프로세스에 실행 시간을 배분합니다.

### 5. **커널의 예외적인 실행 방식**

- 커널은 전통적인 의미에서 하나의 실행 단위(프로세스)로 존재하지 않고, **인터럽트나 시스템 호출**을 통해 동작합니다. 즉, 사용자 모드에서 실행되는 프로세스가 커널에 요청을 하거나, 하드웨어 인터럽트가 발생할 때 커널이 활성화되어 해당 작업을 처리합니다.
- 따라서 커널은 독립적인 프로그램처럼 항상 메모리에 상주하며 실행되는 것이 아니라, **필요할 때마다 활성화**되어 시스템 자원을 관리하는 특수한 형태로 동작합니다.

### 결론:

커널은 프로세스가 아닌 이유는, **커널은 운영체제의 핵심 역할을 수행하는 관리자**이며, **프로세스들을 관리하고 통제**하는 상위 개념이기 때문입니다. 프로세스는 응용 프로그램의 실행 단위이지만, 커널은 시스템 전체의 자원을 제어하고 관리하며, 시스템의 안정성과 보안을 보장하는 **운영체제의 중심부**입니다.

커널의 실체(2)
 커널은 스스로 실행되는 프로세스인가? NO
 커널은 함수들의 단순 집합, 시스템 호출을 통해 호출되는 함수들
 커널이 스케줄링한다(x)
◼ 커널 프로세스가 실행되면서 주기적으로 스케줄링한다(x)
◼ 시스템 호출과 인터럽트 서비스 루틴에 의해 커널 내 스케줄러 함수가 호출되어 실행(0)
 커널은 실행 중이다? NO
 커널은 프로세스도 스레드도 아니므로 NO
 커널이 실행 중이다(x)
◼ 응용프로그램이 시스템 호출을 하여 커널 코드를 실행하고 있다(0)
◼ 인터럽트가 발생하여 인터럽트 서비스 루틴이 실행되고 있다(0)
 커널은 스택이나 힙을 가지는가? NO
 커널은 스택이나 힙을 가지는 주체가 아니다. 그러므로 NO
 스택이나 힙을 가지는 주체는 프로세스나 스레드
◼ 교재 P.75, P.134, P.205 참고
 스레드마다 사용자 스택과 커널 스택 소유
◼ 스레드가 생성될 때 프로세스의 사용자 공간에 사용자 스택 할당
◼ 사용자 코드가 실행되는 동안 활용
◼ 스레드가 생성될 때 커널 공간에 커널 스택 할당
◼ 스레드가 시스템 호출로 커널 코드를 실행할 때 스택으로 활용

응용프로그램 빌딩

라이브러리

응용프로그램에서 활용하도록 미리 작성된 함수들

컴파일 되어 바이너리 형태로 제공되는 파일

개발자는 라이브러리 활용없이 응용프로그램 작성 불가능

응용프로그램이 활용하는 라이브러리는 2가지 유형
 표준 라이브러리(Standard Library)
◼ 사용자가 작성하기 힘든 함수 제공
◼ 운영체제나 컴퓨터 하드웨어에 상관없이 이름과 사용법 동일
◼ 운영체제나 하드웨어, 컴파일러에 관계없이 호환
 시스템 호출 라이브러리(System Call Library)
◼ 시스템 호출 함수들 포함
◼ 시스템 호출 함수들은 시스템 호출을 진행하여 커널 모드로 바꾸고 커널로 진입하
여 커널에 만들어진 함수 실행(커널의 다양한 기능 수행)
◼ 운영체제마다 시스템 호출 함수의 이름이 서로 다름
◼ 운영체제 비호환
◼ 시스템 호출 함수를 커널 API(Application Programming Interface)라고 부름

사용자 코드와 라이브러리 코드의 링킹
 실행 파일이 만들어지는 과정
 응용프로그램 코드는 라이브러리 코드와의 링킹을 거쳐 하나의
실행 파일로 만들어짐
 응용프로그램 실행
 응용프로그램이 사용자 공간에 적재
◼ 실행 파일 내 사용자 코드와 라이브러리 코드의 메모리 적재
◼ 실행 파일 내 사용자 전역 변수와 라이브러리의 전역 변수 모두 메모
리 적재
 응용프로그램은 사용자 모드로 실행 시작
 사례) 다음 슬라이드

메인 함수에 표준 라이브러리에 들어가 있음

함수 호출 write() , open() - 시스템 호출 라이브러리

시스템 호출을 통해서 내부적으로 실행 됨



// 20241024

함수 호출 라이브러리 활용

-사용자 공간에서 사용자 모드 호출

함수 호출 과정

-사용자 공간의 스택에 돌아올 주소, 매개변수 전달, 호출된 지역변수 생성

-사용자 공간에 적재된 함수의 주소로 점프

-함수가 끝나면 함수를 호출한 곳으로 복귀

시스템 호출로 커널 코드 실행

-시스템 호출 라이브러리에 포함된 시스템 호출 함수가 시스템 호출 일으킴

시스템 호출 과정

-시스템 호출을 일으키는 특별한 기계 명령 실행
- 이 명령이 사용자 모드에서 커널 모드로 전환, 커널 함수마다 매겨진 고유 번호 전달
-커널의 시스템 호출 핸들러 실행
-시스템 호출 핸들러가 전달받은 커널 함수의 고유 번호 분석, 해당 커널 함수 호출

-커널 함수에서가 리턴할 때 사용자 모드로 전환, 사용자 프로그램으로 복귀

시스템 호출

 사용자 공간의 코드에서 커널 서비스를 요청하는 과정
◼ 사용자 공간의 코드가 커널 함수를 호출하는 과정
◼ 커널 콜(kernel call), 트랩(trap) 로도 불림
◼ 응용프로그램에서 커널 기능을 활용하도록 만들어 놓은 기능
 운영체제는 시스템 호출 라이브러리 제공
◼ 시스템 호출 함수 혹은 커널 API 포함
◼ Unix/Linux의 커널 API – open(), read(), write(), fork(), exit()
◼ Windows의 커널 API – CreateProcess(), WaitForSingleObject()
◼ 대략 200개 이상의 시스템 호출 함수 있음
 시스템 호출을 일으키는 기계 명령
 CPU마다 시스템 호출을 실행하는 특별한 기계 명령 제공
◼ 시스템 호출 CPU 명령
 사례
◼ int 0x80 - 인텔의 x86계열의 CPU, 32비트에서 사용
◼ syscall/sysret - AMD에서 최초 구현. 64비트에서만 작동
◼ sysenter/sysexit - Intel에서 최초 구현, X86/64 CPU, AMD
 표준 라이브러리를 통해 간접적으로 이루어지는 시스템 호출
 응용프로그램 -> 시스템 호출 라이브러리의 시스템 호출 함수 -> 시스템 호출 CPU 명령
 응용프로그램 -> 표준 라이브러리 함수 -> 시스템 호출 라이브러리의 시스템 호출 함수 ->
시스템 호출 CPU 명령

2장 62~63페이지 공부

시스템 호출은 함수 호출에 비해 많은 시간 비용

fread()와 read()의 동작 비교

fread()의 경우 시스템 호출이 1번 , read()의 경우 시스템 호출 10번

인터럽트

-입출력 장치들이 비동기적 사건을 cpu에게 알리는 행위

비동기적이란 예정되지 않거나 발생시간을 예측할 수 없는 사건

(키보드 입력 , 네트워크로부터 데이터 도착 등)

-하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉨

하드웨어 인터럽트는 장치들이 어떤 상황 발생을 cpu에게 알리는 하드웨어 신호

소프트웨어 인터럽트는 cpu명령으로 발생시키는 인터럽트

컴퓨터에서 인터럽트 활용

-마우스를 움직이거나 클릭하는 등 마우스 조작 , 키보드 입력 , 네트워크로부터 데이터 도착 , usb 메모리 부착 혹은 해제

인터럽트는 다중프로그래밍 실현의 키

-다중프로그래밍 리뷰

여러 프로세스를 동시에 실행 , 한 프로세스가 입출력을 시행하면 다른 프로세스로 교체 실행

입출력이 완료될 때 , 장치로부터 입출력 완료 통보를 받는 방법 필요 → 그게 인터럽트

인터럽트가 없다면 - 다중프로그래밍 운영체제의 구현은 사실상 거의 불가능

인터럽트가 없다면 cpu는 입출력 완료를 계속 검사하는 폴링(polling)을 실행해야 하므로 매우 비효율적

인터럽트 효과

-입출력 장치와 cpu가 동시에 각자의 작업 실행 

입출력 장치는 지시받은 입출력 진행 , cpu는 다른 프로그램 실행

-컴퓨터 시스템이 효율적으로 작동

cpu 활용률이 높아지고 , 시스템 처리율 향상